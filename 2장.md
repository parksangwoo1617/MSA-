# 핵심 내용

- 소프트웨어 아키텍처의 정의와 중요성
- 분해패턴을 적용하여 비즈니스 능력 및 하위 도메인 별로 애플리케이션을 서비스로 분해
- DDD의 경계 컨텍스트 개념을 활용하여 복잡하게 얽힌 데이터를 분해하기 더 쉽게 풀기

## DDD(Domain-Driven Design, 도메인 주도 설계)

# 마이크로서비스 아키텍처란 무엇인가?

- 마이크로서비스 아키텍처의 핵심 사상은 기능 분해(서비스로 나눔)
    - 서비스가 무엇이고 그 크기는 어느 정도가 적당한가?

**소프트웨어의 품질 속성, 즉 '~성'으로 끝나는 지표가 아키텍처에 의해 결정된다.**  - 아키텍처가 중요한 이유

# 소프트웨어 아키텍처의 정의와 중요성

## 소프트웨어 아키텍처의 정의

- 소프트웨어 엘리먼트와 그들 간의 관계, 그리고 이 둘의 속성으로 구성된 시스템을 추론하는데 필요한 구조의 집합 (렌 바스의 연구소 직원들이 내린 정의)
- 애플리케이션 아키텍처 → 여러파트(엘리먼트)로의 분해와 이런 파트 간의 관계(연관성)
    - 엘리먼트 분해가 중요한 이유
        1. 업무와 지식을 분리한다. → 전문 지식을 보유한 사람들이 함께 생산적으로 애플리케이션 작업을 할 수 있다.
        2. 소프트웨어 엘리먼트가 어떻게 상호 작용하는지 밝힌다.

## 소프트웨어 아키텍처의 4+1 뷰 모델

- 필립 크러첸은 소프트웨어 아키텍처가 4+1 뷰 모델이라고 기술한 논문을 발표했다.
- 상이한(서로 다른) 4뷰를 정의한다.
- 각 뷰는 아키텍처의 특정한 측면을 기술하고 특정 소프트웨어 엘리먼트와 그들 사이의 관계로 구성된다.
    - 각 뷰의 목적
        - 논리 뷰: 개발자가 작성한 소프트웨어 엘리먼트. 객체 지향 언어라면 클래스, 패키지가 해당되며 상속, 연관, 의존 등 클래스와 패키지의 관계를 말한다.
        - 구현 뷰: 빌드 시스템의 결과물. 모듈과 컴포넌트로 구성됨. 자바에선 모듈은 JAR, 컴포넌트는 WAR 또는 실행 가능한 JAR파일을 말함.
        - 프로세스 뷰:  런타임 컴포넌트. 각 엘리먼트는 개발 프로세스고, IPC는 프로세스 간 관계를 나타낸다.
        - 배포 뷰: 프로세스가 머신에 매핑되는 방법. 이 뷰의 엘리먼트는 머신 및 프로세스고, 머신 간의 관계가 바로 네트워킹이다.

      ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f2e8025f-f1d6-45f2-b04d-7e53c5e610a4/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f2e8025f-f1d6-45f2-b04d-7e53c5e610a4/Untitled.png)

      4뷰 외에도 (4+1 모델의 +1에 해당하는) 뷰를 구동시키는 시나리오가있다. 각 시나리오는 특정 뷰 내에서 얼마나 다양한 아키텍처 요소가 협동하여 요청을 처리하는지 기술한다.

      **4뷰는 중요한 아키텍처 측면을, 시나리오는 뷰의 여러 엘리먼트가 협동하는 과정을 명시한다.**

      ## 아키텍처의 중요성

      애플리케이션 요건은 크게 두 가지 종류로 나뉜다.

        1. 애플리케이션이 해야 할 일을 정의한 기능 요건
            - 보통 유스 케이스나 사용자 스토리 포맷으로 기술하는데, 이 기능 요건과 아키텍처는 거의 무관하다.
        2. 이른바 '~성'으로 끝나는 서비스 품질 요건
            - 아키텍처는 이 요건을 충족시킬 수 있게 설계해야 한다.
            - 확장성, 신뢰성 같은 런타임 품질 외에도 관리성, 테스트성, 배포성과 같은 개발시점의 품질도 해당된다.

# 아키텍처 스타일

소프트웨어 아키텍처 지식 체계의 선구자인 데이비드 갈란과 메리 쇼가 정의한 아키텍처 스타일

**소프트웨어 아키텍처 개요**

```
아키텍처 스타일은 체계적인 조직의 관점에서 시스템 군을 정의한다. 
좀 더 구체적으로 말하면, 아키텍처 스타일은 그 스타일로 만든 인스턴스에서
사용 가능한 컴포넌트와 커넥터의 보케블러리, 그리고 이들을 조합할
수 있는 제약 조건을 결정한다.
```

- 특정 아키텍처 스타일은 엘리먼트와 관계의 한정된 팔레트(사용 가능한 범위)를 제공하며, 이를 토대로 애플리케이션 아키텍처의 뷰를 정의할 수 있다.

## 계층화 아키텍처 스타일

- 소프트웨어 엘리먼트를 계층별로 구성하는 계층화 아키텍처
    - 전형적인 아키텍처 스타일
- 계층마다 명확히 정의된 역할을 분담하며, 계층 간 디펜던시는 아키텍처로 제한한다. 따라서 어떤 계층은 하위에 위치한 어느 한 계층에 의존한다.

**계층화 아키텍처의 흠**

- 표현 계층이 하나뿐이다.
- 영속화 계층이 하나뿐이다.
- 비즈니스 로직 계층을 영속화 계층에 의존하는 형태로 정의한다.

## 육각형 아키텍처 스타일

- 계층화 아키텍처의 문제점을 해결하고자 고안됨.
- 논리 뷰를 비즈니스 로직 중심으로 구성하는 계층화 아키텍처 스타일의 대안
- 애플리케이션에 표현 계층 대신 비즈니스 로직을 호출하여 외부에서 들어온 요청을 처리하는 인바운드 어댑터와 영속화 계층 대신 비즈니스 로직에 의해 호출되고 외부 애플리케이션을 호출하는 아웃바인드 어댑터를 둔다.
- 비즈니스 로직이 어댑터에 전혀 의존하지 않는 것이 특장점이다.

### 포트

- 비즈니스 로직에는 하나 이상의 포트가 있다.
- 비즈니스 로직이 자신의 외부 세계와 상호작용하는 방법이 정의된 작업 (ex Java에선 인터페이스)
- 포트 종류에는 인바운드/아웃바운드가 있다.
    - 인바운드
        - 비즈니스 로직이 표출된 API로서, 외부 애플리케이션은 이 API를 통해 비즈니스 로직을 호출한다.
    - 아웃바운드
        - 비즈니스 로직이 외부 시스템을 호출하는 방법에 관한것

      ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f0ca6f48-6e46-49ba-8feb-0553228817ab/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f0ca6f48-6e46-49ba-8feb-0553228817ab/Untitled.png)

- 어댑터는 비즈니스 로직 주변을 감싸고 있다. 포트처럼 어댑터도 인바운드/아웃바운드 두 종류이다.
    - 인바운드 어댑터는 외부에서 들어온 요청을 인바운드 포트를 호출해 처리한다. 동일한 인바운드 포트를 여러 인바운드 어댑터가 호출할 수 있다.
    - 아웃바운드 어댑터는 비즈니스 로직에서 들어온 요청을 외부 애플리케이션/서비스를 호출해서 처리한다. 이벤트를 발행하기도 한다.

# 마이크로서비스 아키텍처는 일종의 아키텍처 스타일이다.

- 모놀리식 아키텍처는 구현 뷰를 단일 컴포넌트(하나의 실행 파일이나 WAR 파일)로 구성한 아키텍처 스타일.
- 육각형 아키텍처 방식으로 구성한 논리 뷰를 가질 수 있다.
- 마이크로서비스는 구현 뷰를 다수의 컴포넌트(서비스)로 구성한다.
    - 각 서비스는 자체 논리 뷰 아키텍처를 갖고 있다 → 전형적인 육각형 아키텍처
    - 커넥터는 이런 서비스가 서로 협동할 수 있게 해주는 통신 프로토콜

  ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7982fb29-51ac-4d3f-b062-e5f64ce5f62a/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7982fb29-51ac-4d3f-b062-e5f64ce5f62a/Untitled.png)

    - 마이크로서비스 아키텍처의 핵심 제약 조건: 서비스를 느슨하게 결합
        - 여러 서비스가 협동하는 방식에도 제약사항이 있다.

## 서비스란?

**어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트**

- 클라이언트가 자신이 서비스하는 기능에 접근할 수 있도록 커맨드, 쿼리, 이벤트로 구성된 API를 제공한다.
- 서비스 작업은 크게 커맨드(CUD)와 쿼리(R)로 나뉜다.

서비스 API는 내부 구현 상세를 캡슐화한다. → 애플리케이션 모듈성 보장

각각의 마이크로서비스는 대부분 육각형 아키텍처 형태를 취한다.

API는 서비스에 구현된 비즈니스 로직과 소통하는 어댑터를 이용해 구현한다.

- 작업 어댑터 → 비즈니스 로직 호출
- 이벤트 어댑터 → 데이터 변경시 비즈니스 로직이 내어주는 이벤트 발행

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ddd48237-782b-4493-aa4c-dada9fcda99e/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ddd48237-782b-4493-aa4c-dada9fcda99e/Untitled.png)

- 서비스 구현 뷰는 스탠드얼론(독립적으로 움직이는) 프로세스, 컨테이너 내부에서 실행되는 웹 애플리케이션, OSGI 번들, 서버리스 클라우드 기능 등 다양한 컴포넌트를 사용할 수 있다.

## 느슨한 결합

- 마이크로서비스 아키텍처의 주요 특성 중 하나
- 유지보수성, 테스트성을 높이고 애플리케이션 개발 시간을 단축하는 효과가 있다.
- 서비스는 API를 통해서만 동작하기 때문에 서비스가 직접 DB와 통신하는 일은 불가능하다.
- 클래스 필드 같은 서비스의 영속적 데이터는 반드시 프라이빗으로 유지해야한다.
    - 개발자가 자신이 맡은 서비스의 DB스키마를 변경할 때 다른 서비스 개발자와 조율하느라 시간을 허비하지 않는다.
- DB를 공유하지 않기 때문에 여러 서비스에 걸쳐 데이터를 쿼리하고 일관성을 유지하는 일은 더 복잡해지는 단점이 있다.

## 공유 라이브러리의 역할

- 애플리케이션에서 재사용 가능한 기능을 라이브러리(모듈)로 패키징하는 것은 당연한 일.
- 하지만 패키징하는 것이 때로는 의도치 않은 서비스 간 결합도를 유발할 수 있음.
    - ex) 한 객체를 여러 서비스가 업데이트하는 상황에서 필요한 공용 기능을 라이브러리 하나에 모두 패키징해 배포하면 코드 중복을 줄일 수 있다. 하지만 나중에 요건(요구 사항)이 그 객체에 영향을 주는 방향으로 변경되면 관련 서비스들을 다 다시 빌드해 재배포해야한다.
    - 그래서 변경 가능성이 조금이라도 있는 기능은 별도의 서비스로 구현하고 바뀔 일이 거의 없는 기능은 라이브러리에 담아 쓰는 것이 좋다.

## 서비스 규모는 별로 중요하지 않다.

- 크기보다는 작은 팀이 가장 짧은 시간에, 다른 팀과 협동하는 부분은 최소로 하여 개발 가능한 서비스를 설계해야한다.
- 한 팀이 한 서비스를 맡는 것은 마이크로하지 않다.
- 다른 서비스의 변경분 때문에 내가 맡은 서비스도 계속 바꾸어야 한다거나, 내 서비스 때문에 다른 서비스가 바뀌어야 한다면 서비스가 느슨하게 결합되지 않았다는 반증이다. 또는 분산 모놀리스를 구축했다는 뜻이다.

# 마이크로서비스 아키텍처 정의

***아키텍처를 정의하는 일은 과학보다는 예술에 가깝다!!***

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a26f24de-f800-4652-a857-2708714181b5/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a26f24de-f800-4652-a857-2708714181b5/Untitled.png)

**1단계**는 애플리케이션 요건을 핵심 요청으로 추출하는 것이다.

하지만 필자는 요청을 특정 IPC 기술이 아닌 좀 더 추상적인 관념으로 시스템 작업을 바라볼 것이라고 한다. 시스템 작업은 애플리케이션이 처리하는 요청을 추상화한 것이다.

**2단계**는 어떻게 여러 서비스로 분해할지 결정하는 것이다.

어떤 전략을 구사하든 최종 결과는 기술 개념이 아닌 비즈니스 개념 중심으로 이루어진 서비스들이다.

**3단계**는 서비스별로 API를 정의하는 일이다.

이를 위해 먼저 1단계에서 식별된 시스템 작업을 각 서비스에 배정해야 한다.

대부분 서비스에 추가 지원 작업을 두는 형태가 된다. API 구현 시 사용할 IPC도 정해야 한다.

### 분해 과정의 장애물

1. 네트워크 지연
- 서비스 간 왕복이 너무 잦아 분해할 수 없는 경우
1. 서비스 간 동기 통신으로 인해 가용성이 떨어지는 문제
- 자기 완비형 서비스 개념 사용(3장에서 자세히)
1. 여러 서비스에 걸쳐 데이터 일관성을 지키는 요건
- 사가로 해결(4장에서 자세히)
1. 애플리케이션 도처에 숨어있는 만능 클래스
- DDD 개념을 활용해 제거

## 시스템 작업 식별

<Applying UML and Patterns>(크레이그 라르만)의 객체 지향 설계 프로세스에서 영향을 받은 2단계 프로세스로 시스템 작업을 정의한다.

1단계

시스템 작업을 기술하기 위해 필요한 보케블러리를 제공하는 핵심 클래스로 구성된 고수준의 도메인 모델을 생성.

2단계

시스템 작업 식별 후 그 동작을 도메인 모델 관점에서 기술

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/90377ba9-701c-4a76-8fa7-32a2dbbac715/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/90377ba9-701c-4a76-8fa7-32a2dbbac715/Untitled.png)

도메인 모델은 주로 사용자 스토리의 명사에서 도출한다. (이벤트 스토밍 기법 사용 가능)

시스템 작업은 주로 동사에서 도출하며, 각각 하나 이상의 도메일 객체와 그들 간의 관계로 기술한다.

시스템 작업은 도메인 모델을 생성, 수정, 삭제하거나 모델 간 관계를 맺고 끊을 수 있다.

## 고수준 도메인 모델 생성

시스템 작업 정의 전, 고수준 도메인 모델을 그려본다. 최종적으로 구현할 모델보다는 훨씬 단순한 모델이다.

고수준 도메인 모델은 시스템 작업의 동작을 기술하는데 필요한 보케블러리를 정의한다.

도메인 모델은 스토리에 포함된 명사를 분석하고 표준기법을 활용해 생성한다.

예를 들어 주문하기 스토리는 다음과 같이 다양한 사용자 시나리오로 확장시킬 수 있다.

## 전제(Given)

- 소비자가 있다.
- 음식점이 있다.
- 음식점은 소비자의 주소로 제시간에 음식을 배달할 수 있다.
- 주문 총액이 음식점의 최소 주문량 조건에 부합한다.

## 조건(When)

- 소비자가 음식점에 음식을 주문한다.

## 결과(Then)

- 소비자 신용카드가 승인된다.
- 주문이 PENDING_ACCEPTANCE 상태로 생성된다.
- 생성된 주문이 소비자와 연관된다.
- 생성된 주문이 음식점과 연관된다.

이 시나리오에서 소비자, 주문, 음식점, 신용카드와 같은 명사로 클래스를 만들 수 있다.

마찬가지로 주문 접수 스토리도 다음 시나리오로 확장한다.

## 전제(Given)

- 현재 주문은 PENDING_ACCEPTANCE 상태이다.
- 주문 배달 가능한 배달원이 있다.

## 조건(When)

- 주문을 접수한 음식점은 언제까지 음식을 준비할 수 있다고 약속한다.

## 결과(Then)

- 주문 상태가 ACCEPTED로 변경된다.
- 주문의 promiseByTime 값을 음식점이 준비하기로 한 시간으로 업데이트한다.
- 주문을 배달할 배달원을 배정한다.

이 시나리오에서도 여러 명사들을 이용해 클래스를 도출해낼 수 있다.

이러한 분석을 반복하다보면 핵심 클래스로 구성된 도메인 모델이 완성된다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7933b920-60c6-4b73-8cde-9c203cc94863/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7933b920-60c6-4b73-8cde-9c203cc94863/Untitled.png)

## 시스템 작업 정의

애플리케이션이 어떤 요청을 처리할지 식별하는 단계

크게 다음 두 종류로 나뉜다.

- 커맨드: 데이터 생성, 수정, 삭제 (CUD)
- 쿼리: 데이터 읽기(R)

시스템 커맨드를 식별하려면 사용자 스토리/시나리오에 포함된 동사를 먼저 분석한다. ex) 주문하기 스토리 → 주문 생성 작업

커맨드는 매개변수, 반환값, 동작 방식의 명세를 도메인 모델 클래스로 정의한다.

- 이 명세는 작업 호출 시 충족되어야 할 선행 조건, 작업 호출 후 충족되어야 할 후행 조건으로 구성된다.

ex) createOrder() 시스템 작업의 명세는 다음과 같이 정의된다.

**선행 조건**

- 소비자가 존재하고 주문을 할 수 있다.
- 주문 품목은 음식점의 메뉴 항목에 들어있다.
- 배달 주소/시각은 음식점에서 서비스할 수 있다.

**후행 조건**

- 소비자 신용카드는 주문 금액만큼 승인 처리되었다.
- 주문은 PENDING_ACCEPTANCE 상태로 생성되었다.

다음은 acceptOrder() 시스템 작업의 명세이다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6474cf0d-37cc-4384-815d-edd13b5f796f/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6474cf0d-37cc-4384-815d-edd13b5f796f/Untitled.png)

아키텍처와 연관된 시스템 작업은 대부분 커맨드이다.

애플리케이션에서는 사용자가 의사 결정을 하는 데 필요한 정보를 UI에 제공하는 쿼리도 제공해야 한다.

시스템 작업을 정의한 후에는 애플리케이션 서비스를 식별한다. 서비스를 기계적으로 식별하는 방법은 없지만 다양한 분해 전략을 선택할 수는 있다.

어떤 분해 전략을 사용하든 최종적으로는 기술 개념이 아닌 비즈니스 개념 중심으로 서비스가 구성된다.

# 서비스 정의(비즈니스 능력 패턴별 분해)

## 비즈니스 능력 식별

한 조직의 비즈니스 능력은 조직의 목표, 구조, 비즈니스 프로세스를 분석하여 식별한다.

비즈니스 능력 명세는 입력, 출력, SLA 등 다양한 컴포넌트로 구성된다.

ex) 보험사 증권 인수 능력 → 입력: 소비자 신청서, 출력: 승인과 단가

비즈니스 능력은 보통 특정 비즈니스 객체에 집중하며, 여러 개의 하위 능력으로 분해할 수 있다.

ex) 클레임이라는 비즈니스 객체 → 중심: 클레임 관리, 하위: 클레임 정보 관리, 클레임 검토, 클레임 지불 관리 등

## 비즈니스 능력을 여러 서비스로

비즈니스 능력을 식별한 후 능력에 따라 또는 연관된 능력 그룹에 따라 서비스를 정의한다.

서비스를 정의할 때 최상위 능력이 바로 매핑될 수도 있고 하위 능력이 매핑될 수도 있다.

능력 레벨 매핑 기준

- 상이한 성격의 비즈니스 능력 → 각각 다른 서비스로 매핑
- 비슷한 성격의 비즈니스 능력 → 같은 서비스로 매핑

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/377ea41c-9380-4b1e-830e-9d8f024b1f8f/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/377ea41c-9380-4b1e-830e-9d8f024b1f8f/Untitled.png)

# 서비스 정의: 하위 도메인 패턴별 분해

DDD는 도메인 내부에서 문제 해결이 가능한 형태로 도메인을 모델링하는 기법이다. 도메인을 구성하는 각 하위 도메인마다 도메인 모델을 따로 정의한다.

하위 도메인은 비즈니스 능력과 같은 방법으로 식별하므로 비즈니스 능력과 유사한 하위 도메인이 도출된다.

**경계 컨텍스트**: 도메인 모델의 범위 (도메인 모델을 구현한 코드 아티팩트를 포함) 마이크로서비스아키텍처에 DDD를 적용하면 각 서비스가 경계 컨텍스트가 된다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/28cc7df7-7317-41b9-868f-fb711bf05ecd/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/28cc7df7-7317-41b9-868f-fb711bf05ecd/Untitled.png)

# 분해지침

## 단일 책임 원칙(Single Responsibility Principle)

**클래스는 오직 하나의 변경 사유를 가져야 한다.**

## 공통 폐쇄 원칙(Common Closure Principle)

**패키지의 클래스들은 동일한 유형의 변경에 대해 닫혀 있어야 한다. 패키지에 영향을 주는 변경은 그 패키지에 속한 모든 클래스에 영향을 끼친다.**

- 어떤 두 클래스가 동일한 사유로 맞물려 변경되면 동일한 패키지에 있어야 한다.
- CCP를 적용해서 마이크로서비스 아키텍처를 구축하면 동일한 사유로 변경되는 컴포넌트를 모두 같은 서비스로 묶을 수 있다.

# 서비스 분해의 장애물

마이크로서비스 아키텍처를 구축할 때 장애 요소

## 네트워크 지연

- 분산 시스템의 고질적인 문제
- 한 차례 왕복으로 여러 객체를 한 번에 가져오는 배치 API를 구현하거나, 값비싼 IPC를 언어 수준의 메서드나 함수 호출로 대체하는 식으로 해결

## 동기 IPC로 인한 가용성 저하

- createOrder()같은 동작은 타 서비스 중 하나라도 불능일 경우 주문이 생성되지 않는다.
- 비동기 메시징(3장)으로 강한 결합도를 제거하고 가용성을 높인다.

## 여러 서비스에 걸쳐 데이터 일관성 유지

- 요청 하나로 두 개 이상의 서비스에서 데이터 업데이트가 발생할 때, 업데이트는 원자적으로 일어나야한다.
- 과거에는 커밋 방식의 2단계 분산 트랜잭션을 많이 썼지만, 요즘은 사가라는 전혀 다른 방식으로 트랜잭션을 관리해야한다.
- 사가는 메시징을 이용한 일련의 로컬 트랜잭션이다.
- 한 가지 단점은 최종 일관성을 보장한다는 것이다.

## 일관된 데이터 뷰 확보

- 마이크로서비스 아키텍처는 각 서비스의 DB가 일관적이라 해도 전역 범위에서 일관된 데이터 뷰는 확보할 수 없다.

## 만능 클래스는 분해의 걸림돌

애플리케이션의 여러 측면의 상태/동작을 보이지 않게 감싸고 있기 때문에 이 클래스를 사용하는 전체 비즈니스 로직을 서비스로 분리하려면 골치아프다.

Order 클래스를 라이브러리로 묶고 Order DB를 중앙화해서 주문을 처리하는 모든 서비스가 이 라이브러리를 통해 DB에 접근하도록 만드는 방법이 있지만 그것은 마이크로서비스 아키텍처의 핵심 원칙에 위배되어 결국 단단히 결합된 바람직하지 못한 구조가 된다.

- DDD를 적용하여 각 서비스를 자체 도메인 모델을 갖고 있는 개별 하위 도메인으로 취급하면 문제가 해결된다.
- DDD를 적용했을 때 각 도메인 모델의 클래스는 동일한 비즈니스 엔티티의 상이한 측면을 나타낸다.

# 서비스 API 정의

외부 클라이언트 또는 타 서비스가 호출하는 시스템 작업과 서비스 간 협동을 지원하기 위해 타 서비스 호출 전용으로 만든 작업 둘 중 하나

서비스 이벤트는 주로 타 서비스와 협동하기 위해 발행한다.

서비스 API를 정의하려면 우선 각각의 시스템 작업을 서비스로 매핑한 후, 그 시스템 작업을 구현하려면 어느 서비스가 서로 협동해야 할지 파악해야한다.

## 1. 시스템 작업을 서비스로 배정

제일 먼저 어느 서비스가 요청의 진입점인지 결정해야한다. 대부분의 시스템 작업은 자연스레 서비스로 매핑되지만, 간혹 매핑 관계가 분명하지 않을 때도 있다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96d637c6-e358-441e-ad78-88d2af12ee53/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96d637c6-e358-441e-ad78-88d2af12ee53/Untitled.png)

시스템 작업을 각 서비스에 배정한 후, 각 시스템 작업을 처리하기 위해 서비스가 어떻게 협동해야 할지 정한다.

## 2. 서비스 간 협동 지원에 필요한 API 확정

서비스 하나로 전부 처리 가능한 시스템 작업도 있지만, 작업은 대부분 여러 서비스에 걸쳐 있다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/80dc40ab-dc10-4b55-88cb-779c16fa738e/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/80dc40ab-dc10-4b55-88cb-779c16fa738e/Untitled.png)

각 시스템 작업을 면밀히 분석해서 서로 어떻게 협동해야할지 결정해야한다.