# 모놀리식 아키텍처의 장점

**서비스 크기가 그렇게 크지 않을 때**

- 개발이 간단하다.
- 애플리케이션을 쉽게 변경할 수 있다.
- 테스트하기 쉽다.
- 배포하기 쉽다.
- 확장하기 쉽다.

## 확장 큐브

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/220b86e5-89d8-4cc3-9dc9-8898ed103c0a/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/220b86e5-89d8-4cc3-9dc9-8898ed103c0a/Untitled.png)

### X축 확장: 다중 인스턴스에 고루 요청 분산

- 애플리케이션의 능력과 가용성 개선

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4e0a2155-a763-4af2-b196-68fab5631131/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4e0a2155-a763-4af2-b196-68fab5631131/Untitled.png)

### Z축 확장: 요청 속성별 라우팅

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fb79f6c7-d239-4002-bb3d-5e38e4a17e5d/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fb79f6c7-d239-4002-bb3d-5e38e4a17e5d/Untitled.png)

### Y축 확장: 기능에 따라 애플리케이션을 서비스로 분해

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/334430d3-02f7-4afd-b7b6-575c024b994c/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/334430d3-02f7-4afd-b7b6-575c024b994c/Untitled.png)

## SOA(Service Oriented Architecture)와 마이크로서비스 아키텍처

### 공통점

- 시스템을 여러 서비스로 구성하는 아키텍처 스타일

### 차이점

- 서비스 간 통신
    - SOA: SOAP, WS* 표준처럼 무거운 프로토콜을 응용한 엔터프라이즈 서비스 버스 중심의 스마트 파이프(smart pipe)
    - 마이크로서비스: REST나 gRPC처럼 가벼운 프로토콜을 응용한 메시지 브로커 또는 서비스 간 통신 중심의 덤 파이프(dumb pipe)
- 데이터
    - SOA: 전역 데이터 모델 및 공유 DB
    - 마이크로서비스: 서비스 개별 데이터 모델 및 DB
- 주요 사례
    - SOA: 대규모 모놀리식 애플리케이션
    - 마이크로서비스: 소규모 서비스

## 마이크로서비스 아키텍처의 장점

- 크고 복잡한 애플리케이션을 지속적으로 전달/배포할 수 있다.
- 서비스 규모가 작아 관리하기 쉽다.
- 서비스를 독립적으로 배포/확장할 수 있다.
- 마이크로서비스 아키텍처 덕분에 팀이 자율적으로 움진인다.
- 결함 격리가 잘된다.
- 새로운 기술을 실험하고 도입하기 쉽다.

## 마이크로서비스 아키텍처의 단점

- 딱 맞는 서비스를 찾기가 쉽지 않다.
- 분산 시스템은 너무 복잡해서 개발, 테스트, 배포가 어렵다.
- 여러 서비스에 걸친 기능을 배포할 때에는 잘 조정해야한다.
- 마이크로서비스 아키텍처 도입 시점을 결정하기가 어렵다.

## 패턴

- 특정한 상황에서 발생한 문제에 대한 재사용 가능한 해법

## 패턴 언어

- 특정 영역 내부에서 문제를 해결하는 연관된 패턴의 집합

## 패턴의 구조

### 강제 조항: 문제 해결을 위해 반드시 처리해야 할 이슈

### 결과 맥락: 패턴 적용 결과

- 장점: 패턴의 좋은 점
- 단점: 패턴의 나쁜 점
- 이슈: 패턴 적용 시 발생한 새로운 문제점

### 연관 패턴: 다섯 가지 관계 유형

- 선행자: 이 패턴을 필요하게 만든 선행 패턴
- 후행자: 이 패턴으로 야기된 이슈를 해결하는 패턴
- 대안: 이 패턴의 대체 솔루션을 제공하는 패턴
- 일반화: 문제를 해결하는 일반적인 솔루션에 해당하는 패턴
- 세분화: 특정 패턴을 더 세부적으로 나타낸 형태

## 마이크로서비스 아키텍처 패턴 언어

- 전체 애플리케이션을 마이크로서비스 아키텍처로 구성할 때 유용한 패턴의 모음집
- 패턴 언어는 여러 그룹의 패턴으로 구성됨.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/053c3c9b-b64c-4677-bdf8-cc5279a644c4/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/053c3c9b-b64c-4677-bdf8-cc5279a644c4/Untitled.png)

### 패턴 계층

- 위의 패턴에서 세 계층으로 분류된다.
    - 인프라 패턴: 개발 영역 밖의 인프라 문제를 해결
    - 애플리케이션 인프라: 개발에도 영향을 미치는 인프라 문제 해결
    - 애플리케이션 패턴: 개발자가 맞닥뜨리는 문제 해결

### 애플리케이션을 여러 서비스로 분해하는 패턴

- 비즈니스 능력에 따라 분해
- 하위 도메인에 따라 분해

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/56eec129-b744-4def-a091-feb62c91eb98/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/56eec129-b744-4def-a091-feb62c91eb98/Untitled.png)

### 통신 패턴

- 마이크로서비스 아키텍처로 구축한 애플리케이션은 기본적으로 분산 시스템이기 때문에 프로세스 간 통신이 아주 중요하다. 그러므로 서비스 상호 간, 그리고 외부 세계와 어떻게 통신하면 좋을지 아키텍처/설계 관점에서 다양한 의사 결정을 해야한다.
- 통신 패턴은 크게 다섯 그룹으로 정리할 수 있다.
- **통신 그룹**
    - 통신 스타일: 어떤 종류의 IPC를 사용하는가?
    - 디스커버리: 서비스 클라이언트는 서비스 인스턴스의 IP주소를 어떻게 가져오는가?
    - 신뢰성: 서비스 불능 시 서비스 간 통신의 신뢰성은 어떻게 보장되는가?
    - 트랜잭셔널 메시징: 비즈니스 데이터를 업데이트하는 DB 트랜잭션에 메시지를 송신하고 이벤트를 발행하는 행위를 어떻게 통합하는가?
    - 외부 API: 애플리케이션 클라이언트는 서비스와 어떻게 통신하는가?

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7665b0d8-9931-458c-90b2-cfaa373a7c8e/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7665b0d8-9931-458c-90b2-cfaa373a7c8e/Untitled.png)

## 트랜잭션 관리를 위한 데이터 일관성 패턴

- 마이크로서비스는 서비스마다 DB를 갖고 서로 느슨하게 결합한다. 이때 DB를 따로 두면 몇 가지 중요한 문제가 생긴다.
- 기존의 분산 트랜잭션은 요즘 애플리케이션에는 안 맞는 방법이라서 사가 패턴에 따라 데이터 일관성을 유지해야한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c977f428-f73f-44e4-a288-c333ddf8b7bc/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c977f428-f73f-44e4-a288-c333ddf8b7bc/Untitled.png)

## 데이터 쿼리 패턴

- 서비스마다 DB를 두면 각 서비스가 소유한 데이터를 조인하는 쿼리도 문제이다. 서비스 데이터는 오직 그 서비스의 API를 통해서만 접근할 수 있기 때문에 DB에 분산 쿼리를 사용할 수가 없다. 그래서 이런 쿼리는 다음 그림에 표시된 두 가지 패턴을 응용해서 구현한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f85f3373-f590-440d-9d42-c4ec32e9604c/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f85f3373-f590-440d-9d42-c4ec32e9604c/Untitled.png)

- API 조합 패턴이나 CQRS 둘 중 하나를 사용해서 쿼리 문제를 해결한다.
- API 조합 패턴은 하나 이상의 서비스를 호출해서 그 결과를 조합하고, CQRS(Command Query Responsibility Segregation)는 하나 이상의 데이터 레플리카(복제본)를 유지해서 쉽게 쿼리하는 방식이다.

## 서비스 배포 패턴

- 마이크로서비스 애플리케이션은 다양한 언어와 프레임워크로 구현된 수십~ 수백 개의 서비스로 이루어져 있기 때문에 배포 작업이 훨씬 더 복잡하고 관리할 가동부가 상당히 많다.
- 고도로 자동화한 배포 인프라가 필요하다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c32be7f9-c720-4a57-8d0e-12d2fc99bf91/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c32be7f9-c720-4a57-8d0e-12d2fc99bf91/Untitled.png)

## 관측성 패턴: 애플리케이션 동작 파악

- 모놀리식 애플리케이션은 요청이 들어온 인스턴스의 로그 파일을 찾아보면 애플리케이션의 동작을 쉽게 파악할 수 있지만 마이크로서비스 아키텍처는 요청 결과가 클라이언트에 반환되기까지 어떤 서비스를 어떻게 오갈지 알 수 없기 때문에 로그 파일 하나만으로는 원인을 파악할 수 없고 문제의 원인을 찾고 진단하기가 매우 복잡하다.
- 관측 가능한 서비스를 설계하려면 다음과 같은 패턴이 필요하다.
    - 헬스 체크(health check) API: 서비스 헬스(가동 상태)를 반환하는 endpoint을 표출한다.
    - 로그 수집: 서비스 내역을 기록하고 중앙 로깅 서버에 로그를 출력하여 검색/경고 기능을 제공한다.
    - 분산 추적: 각 외부 요청마다 ID를 부여하여 서비스를 통과하는 과정을 추적한다.
    - 예외 추적: 예외가 발생하면 예외 추적 서비스에 보고한다. 이 서비스는 중복된 예외를 걸러내고 개발자에게 경고를 보내거나 그 해결 상태를 추적한다.
    - 애플리케이션 지표: 카운터, 게이지 등의 지표를 측정하여 지표 서버에 표출한다.
    - 감사 로깅: 사용자가 한 일을 기록한다.

## 서비스 테스트 자동화 패턴

- 서비스를 따로 분리해서 테스트하는 테스트 단순화 패턴이 필요하다.
    - 컨슈머 주도 계약 테스트: 클라이언트가 의도한 대로 서비스가 동작하는지 확인한다.
    - 컨슈머 쪽 계약 테스트: 클라이언트와 서비스가 상호 통신 가능한지 확인한다.
    - 서비스 컴포넌트 테스트: 서비스를 따로따로 테스트한다.
- e2e 테스트는 피하는 것이 상책

## 횡단 관심사 처리 패턴

- 신규 서비스 구축 시 횡단(공통) 관심사를 처리하는 프레임워크에서 마이크로서비스 섀시 패턴을 적용하여 서비스를 구축하는 것이 바람직하다.

## 보안 패턴

- 마이크로서비스 아키텍처에서는 일반적으로 API 게이트웨이가 신원, 역할 등 사용자 정보를 인증한 후 호출할 서비스에 관련 정보를 전달한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/27408920-6efb-46b8-8e25-0f043e2b6d3e/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/27408920-6efb-46b8-8e25-0f043e2b6d3e/Untitled.png)

**지속적 전달/배포의 목표는 신속하고 확실하게 소프트웨어를 전달하는 것이다. 다음은 소프트웨어 개발 수준을 평가하는 네 가지 유용한 잣대이다.**

- 배포 빈도: 소프트웨어를 얼마나 자주 프로덕션에 배포하는가?
- 리드 타임: 개발자가 변경분을 체크인할 때부터 프로덕션에 배포할 때까지 걸린 시간
- 평균 복구 시간: 프로덕션 문제 복구에 소요된 시간
- 변경분 실패율: 프로덕션에 문제를 일으킨 변경분의 비율

## 정리

- 모놀리식 아키텍처 패턴은 애플리케이션을 하나의 배포 단위로 구성한다.
- 마이크로서비스 아키텍처 패턴은 독립적으로 배포 가능하면서 자체 DB를 보유한 서비스들로 시스템을 분해한다.
- 단순한 애플리케이션은 모놀리식 아키텍처가, 크고 복잡한 애플리케이션은 마이크로서비스 아키텍처가 더 적합하다.
- 마이크로서비스 아키텍처를 채택하면 자율적은 소규모 팀들이 작업을 병행할 수 있어서 소프트웨어 개발 속도가 빠르다.
- 마이크로서비스 아키텍처는 단점도 있다.
- 마이크로서비스 아키텍처 패턴 언어는 마이크로서비스 아키텍처로 애플리케이션을 설계할 때 유용한 패턴들의 모음집이다.